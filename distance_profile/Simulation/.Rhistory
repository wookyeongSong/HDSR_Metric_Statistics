setwd("~/Documents/research/Hans/HDSR/Clean Code/Simulation")
library(mixtools)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(parallel)
Get_Inverse <- function(u, y,xout) {
temp_y <- numeric(length = length(u))
temp_y <- approx(y, u, xout, rule = 2,ties=min)$y
return(list(x = xout, y = temp_y))
}
met_R1<-function(a,b){return(abs(a-b))}
Dist_profile<-function(w,t,Training_set,metric){
S <- unlist(lapply(Training_set,  function(x) metric(x,w)  ))
n <- length(Training_set)
Out <- sapply(t, function(x) sum(S <= x)/n)
return(Out)
}
Depth_abs<-function(x,Training_set,metric,Q_train,workgrid_p,workgrid_q,tau=0){
w<-exp(-tau*workgrid_q)
Q_i<-Get_Inverse(workgrid_p,Dist_profile(x,workgrid_p,Training_set,metric),workgrid_q)$y
R_i<-sum( abs(Q_train-rep(1,dim(Q_train)[1])%*%t(Q_i) )%*%(w) )/length(Q_i)
return(expit(R_i/dim(Q_train)[1]))
}
####bimodal
n<-40000
mu <- c(-3, 3)
sigma <- c(1, 2)
lambda <- c(0.5, 0.5)
Training_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Calibration_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Training_set<-list();Calibration_set<-list()
for (i in 1:n) {
Training_set[[i]]<-Training_mat[i,1]
Calibration_set[[i]]<-Calibration_mat[i,1]
}
search_grid<-seq(-6,6,0.1)
workgrid_p<-seq(0,12,0.05)
F_b_0<-Dist_profile(-0.9,workgrid_p,Training_set,met_R1)
F_b_3<-Dist_profile(3,workgrid_p,Training_set,met_R1)
F_b_m3<-Dist_profile(-3,workgrid_p,Training_set,met_R1)
plot(workgrid_p,F_b_0,type = "l",col="red")
lines(workgrid_p,F_b_3,type = "l",col="black")
lines(workgrid_p,F_b_m3,type = "l",col="blue")
df_profiles<-list()
for (i in 1:50) {
df_profiles[[i]]<-data.frame(x=workgrid_p,y=Dist_profile(Training_mat[i,1],workgrid_p,Training_set,met_R1))
}
plot2 <- ggplot(data=data.frame(x=workgrid_p , y=F_b_0), aes(x=x, y=y)) + geom_line(color="red",size=1) +
labs(x='r',y='distance profile ')+theme_minimal()+
theme(
axis.title.x = element_text(size = 14),  # Font size for x-axis label
axis.title.y = element_text(size = 14),  # Font size for y-axis label
axis.text.x = element_text(size = 14),   # Font size for x-axis tick labels
axis.text.y = element_text(size = 14),    # Font size for y-axis tick labels
aspect.ratio = 1,
legend.position = "none",
axis.title = element_text(size = 15))
for (i in 1:20) {
plot2<-plot2 + geom_line(data=df_profiles[[i]], aes(x=x, y=y),col="gray",alpha=0.15,size=1)
}
plot2<-plot2 + geom_line(data=data.frame(x=workgrid_p , y=F_b_3), aes(x=x, y=y),col="black",size=1)
plot2<-plot2 + geom_line(data=data.frame(x=workgrid_p , y=F_b_m3), aes(x=x, y=y),color="skyblue",size=1)
plot2<-plot2 + geom_line(data=data.frame(x=workgrid_p , y=F_b_0), aes(x=x, y=y),color="red",size=1)
plot2
#####
workgrid_p<-seq(-10,10,0.05)
density <- lambda[1]*dnorm(workgrid_p, mean = mu[1], sd = sigma[1]) + lambda[2]*dnorm(workgrid_p, mean = mu[2], sd = sigma[2])
df <- data.frame(x = workgrid_p, density = density)
den_3<-lambda[1]*dnorm(3, mean = mu[1], sd = sigma[1]) + lambda[2]*dnorm(3, mean = mu[2], sd = sigma[2])
den_0<-lambda[1]*dnorm(-0.445, mean = mu[1], sd = sigma[1]) + lambda[2]*dnorm(-0.445, mean = mu[2], sd = sigma[2])
den_n3<-lambda[1]*dnorm(-3, mean = mu[1], sd = sigma[1]) + lambda[2]*dnorm(-3, mean = mu[2], sd = sigma[2])
x_interval1 <- c(-4.5, -1.4)
x_interval2 <- c(1.4, 4.7)
plot3<-ggplot(df, aes(x = workgrid_p, y = density)) +
geom_line() +
geom_point(data=data.frame(x=-3,y=den_n3),aes(x = x, y = y) ,color="skyblue2",size=2)+
geom_point(data=data.frame(x=3,y=den_3),aes(x = x, y = y) ,color="black",size=2)+
geom_point(data=data.frame(x=-0.445,y=den_0),aes(x = x, y = y) ,color="red",size=2)+
theme_minimal() +
labs(x = "y",
y = "density")+
theme(
axis.title.x = element_text(size = 14),  # Font size for x-axis label
axis.title.y = element_text(size = 14),  # Font size for y-axis label
axis.text.x = element_text(size = 14),   # Font size for x-axis tick labels
axis.text.y = element_text(size = 14),    # Font size for y-axis tick labels
aspect.ratio = 1,
legend.position = "none",
axis.title = element_text(size = 15))
setwd("~/Documents/research/Hans/HDSR/Clean Code/Simulation")
Get_R<-function(k){
n<-40000
library(mixtools)
Get_Inverse <- function(u, y,xout) {
temp_y <- numeric(length = length(u))
temp_y <- approx(y, u, xout, rule = 2,ties=min)$y
return(list(x = xout, y = temp_y))
}
met_R1<-function(a,b){return(abs(a-b))}
Dist_profile<-function(w,t,Training_set,metric){
S <- unlist(lapply(Training_set,  function(x) metric(x,w)  ))
n <- length(Training_set)
Out <- sapply(t, function(x) sum(S <= x)/n)
return(Out)
}
Depth_abs<-function(x,Training_set,metric,Q_train,workgrid_p,workgrid_q,tau=0){
w<-exp(-tau*workgrid_q)
Q_i<-Get_Inverse(workgrid_p,Dist_profile(x,workgrid_p,Training_set,metric),workgrid_q)$y
R_i<-sum( abs(Q_train-rep(1,dim(Q_train)[1])%*%t(Q_i) )%*%(w) )/length(Q_i)
return(expit(R_i/dim(Q_train)[1]))
}
set.seed(1)
workgrid_x<-seq(2,3,length=100)
search_grid<-seq(-6,6,length=length(workgrid_x) )
workgrid_p<-seq(0,12,0.05)
workgrid_q<-c(0,sort(rbeta(length(workgrid_p),0.5,0.5)) ,1)
Heat_m<-matrix(0,length(workgrid_x),length(search_grid))
Unif_set<-list()
for (i in 1:length(search_grid)) {
Unif_set[[i]]<-search_grid[i]
}
mu <- c(-workgrid_x[k], workgrid_x[k])
sigma <- c(1, 2)
lambda <- c(0.5, 0.5)
Training_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Calibration_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Training_set<-list();Calibration_set<-list()
for (i in 1:n) {
Training_set[[i]]<-Training_mat[i,1]
Calibration_set[[i]]<-Calibration_mat[i,1]
}
dist_profile <- t(matrix(unlist(lapply(Training_set, function(x) Dist_profile(x, workgrid_p, Training_set,met_R1))),
+                            length(workgrid_p) ,length(Training_set) ) )
inv_dist_profile <- apply(dist_profile, 1, function(x) Get_Inverse(workgrid_p, x,workgrid_q)$y)
Q_train <- t(inv_dist_profile)
return(unlist(lapply((Unif_set),function(x) Depth_abs(x,Training_set,met_R1,Q_train,workgrid_p,workgrid_q))) )
}
Get_R<-function(k){
n<-40000
library(mixtools)
Get_Inverse <- function(u, y,xout) {
temp_y <- numeric(length = length(u))
temp_y <- approx(y, u, xout, rule = 2,ties=min)$y
return(list(x = xout, y = temp_y))
}
met_R1<-function(a,b){return(abs(a-b))}
Dist_profile<-function(w,t,Training_set,metric){
S <- unlist(lapply(Training_set,  function(x) metric(x,w)  ))
n <- length(Training_set)
Out <- sapply(t, function(x) sum(S <= x)/n)
return(Out)
}
Depth_abs<-function(x,Training_set,metric,Q_train,workgrid_p,workgrid_q,tau=0){
w<-exp(-tau*workgrid_q)
Q_i<-Get_Inverse(workgrid_p,Dist_profile(x,workgrid_p,Training_set,metric),workgrid_q)$y
R_i<-sum( abs(Q_train-rep(1,dim(Q_train)[1])%*%t(Q_i) )%*%(w) )/length(Q_i)
return(expit(R_i/dim(Q_train)[1]))
}
set.seed(1)
workgrid_x<-seq(2,3,length=100)
search_grid<-seq(-6,6,length=length(workgrid_x) )
workgrid_p<-seq(0,12,0.05)
workgrid_q<-c(0,sort(rbeta(length(workgrid_p),0.5,0.5)) ,1)
Heat_m<-matrix(0,length(workgrid_x),length(search_grid))
Unif_set<-list()
for (i in 1:length(search_grid)) {
Unif_set[[i]]<-search_grid[i]
}
mu <- c(-workgrid_x[k], workgrid_x[k])
sigma <- c(1, 2)
lambda <- c(0.5, 0.5)
Training_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Calibration_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Training_set<-list();Calibration_set<-list()
for (i in 1:n) {
Training_set[[i]]<-Training_mat[i,1]
Calibration_set[[i]]<-Calibration_mat[i,1]
}
dist_profile <- t(matrix(unlist(lapply(Training_set, function(x) Dist_profile(x, workgrid_p, Training_set,met_R1))),
+                            length(workgrid_p) ,length(Training_set) ) )
inv_dist_profile <- apply(dist_profile, 1, function(x) Get_Inverse(workgrid_p, x,workgrid_q)$y)
Q_train <- t(inv_dist_profile)
return(unlist(lapply((Unif_set),function(x) Depth_abs(x,Training_set,met_R1,Q_train,workgrid_p,workgrid_q))) )
}
system.time({
cl <- makeCluster(getOption("cl.cores", 10));
res<-parLapply(cl, 1:100,Get_R)
stopCluster(cl)
rm(cl)
})
stopCluster(cl)
rm(cl)
Get_R<-function(k){
n<-40000
library(mixtools)
Get_Inverse <- function(u, y,xout) {
temp_y <- numeric(length = length(u))
temp_y <- approx(y, u, xout, rule = 2,ties=min)$y
return(list(x = xout, y = temp_y))
}
expit <- function(x) {
return(exp(x)/(1+exp(x)))
}
met_R1<-function(a,b){return(abs(a-b))}
Dist_profile<-function(w,t,Training_set,metric){
S <- unlist(lapply(Training_set,  function(x) metric(x,w)  ))
n <- length(Training_set)
Out <- sapply(t, function(x) sum(S <= x)/n)
return(Out)
}
Depth_abs<-function(x,Training_set,metric,Q_train,workgrid_p,workgrid_q,tau=0){
w<-exp(-tau*workgrid_q)
Q_i<-Get_Inverse(workgrid_p,Dist_profile(x,workgrid_p,Training_set,metric),workgrid_q)$y
R_i<-sum( abs(Q_train-rep(1,dim(Q_train)[1])%*%t(Q_i) )%*%(w) )/length(Q_i)
return(expit(R_i/dim(Q_train)[1]))
}
set.seed(1)
workgrid_x<-seq(2,3,length=100)
search_grid<-seq(-6,6,length=length(workgrid_x) )
workgrid_p<-seq(0,12,0.05)
workgrid_q<-c(0,sort(rbeta(length(workgrid_p),0.5,0.5)) ,1)
Heat_m<-matrix(0,length(workgrid_x),length(search_grid))
Unif_set<-list()
for (i in 1:length(search_grid)) {
Unif_set[[i]]<-search_grid[i]
}
mu <- c(-workgrid_x[k], workgrid_x[k])
sigma <- c(1, 2)
lambda <- c(0.5, 0.5)
Training_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Calibration_mat<-matrix(rnormmix(n , mu = mu, sigma = sigma, lambda = lambda),nrow = n,ncol = 1)
Training_set<-list();Calibration_set<-list()
for (i in 1:n) {
Training_set[[i]]<-Training_mat[i,1]
Calibration_set[[i]]<-Calibration_mat[i,1]
}
dist_profile <- t(matrix(unlist(lapply(Training_set, function(x) Dist_profile(x, workgrid_p, Training_set,met_R1))),
+                            length(workgrid_p) ,length(Training_set) ) )
inv_dist_profile <- apply(dist_profile, 1, function(x) Get_Inverse(workgrid_p, x,workgrid_q)$y)
Q_train <- t(inv_dist_profile)
return(unlist(lapply((Unif_set),function(x) Depth_abs(x,Training_set,met_R1,Q_train,workgrid_p,workgrid_q))) )
}
system.time({
cl <- makeCluster(getOption("cl.cores", 10));
res<-parLapply(cl, 1:100,Get_R)
stopCluster(cl)
rm(cl)
})
workgrid_x<-seq(2,3,length=100)
workgrid_x<-seq(2,3,length=100)
search_grid<-seq(-6,6,length=length(workgrid_x) )
Heat_m<-matrix(0,length(workgrid_x),length(search_grid))
View(res)
Heat_m<-matrix(0,length(workgrid_x),length(search_grid))
for (i in 1:length(workgrid_x)) {
Heat_m[i,]<-res[[i]]
}
df_long <- melt(Heat_m)
colnames(df_long) <- c("x_index", "y_index", "value")
# Map indices to actual coordinates
df_long$x <- scales::rescale(df_long$x_index, to = c(2, 3))       # 1201 columns → [2,3]
df_long$y <- scales::rescale(df_long$y_index, to = c(-6, 6))      # 101 rows → [-6,6]
# Make heatmap
HM<-ggplot(df_long, aes(x = x, y = y, fill = value)) +
geom_raster() +
scale_fill_viridis_c(option = "plasma") +
labs(x = "x", y = "y") +  # removed legend label
theme_minimal( ) +
theme(
legend.position = "none",   # remove legend
panel.grid = element_blank(),  # remove grid lines
axis.title.x = element_text(size = 14),  # Font size for x-axis label
axis.title.y = element_text(size = 14),  # Font size for y-axis label
axis.text.x = element_text(size = 14),   # Font size for x-axis tick labels
axis.text.y = element_text(size = 14),
)
HM
grid.arrange(plot3, plot2,HM, ncol=3)
grid.arrange(HM,plot3, plot2, ncol=3)
dev.copy2pdf(file=paste0('DP_new_2.pdf'),out.type="quartz", width=9, height=3)
save.image("~/Documents/research/Hans/HDSR/Simulation/DP_new_2.RData")
